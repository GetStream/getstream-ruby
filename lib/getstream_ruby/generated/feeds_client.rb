# frozen_string_literal: true

# Code generated by GetStream internal OpenAPI code generator. DO NOT EDIT.

# Load all models at once
Dir[File.join(__dir__, "models", "*.rb")].sort.each { |file| require_relative file }

module GetStream
  module Generated
    # Feeds API client with generated methods
    class FeedsClient
      def initialize(client)
        @client = client
      end
      # Create a new activity or update an existing one
      #
      # @param add_activity_request [AddActivityRequest]
      # @return [Models::AddActivityResponse]
      def add_activity(add_activity_request)
        path = '/api/v2/feeds/activities'
        # Build request body
        body = add_activity_request

        # Make the API request
        @client.make_request(
          :post,
          path,
          body: body
        )
      end

      # Create new activities or update existing ones in a batch operation
      #
      # @param upsert_activities_request [UpsertActivitiesRequest]
      # @return [Models::UpsertActivitiesResponse]
      def upsert_activities(upsert_activities_request)
        path = '/api/v2/feeds/activities/batch'
        # Build request body
        body = upsert_activities_request

        # Make the API request
        @client.make_request(
          :post,
          path,
          body: body
        )
      end

      # Delete one or more activities by their IDs
      #
      # @param delete_activities_request [DeleteActivitiesRequest]
      # @return [Models::DeleteActivitiesResponse]
      def delete_activities(delete_activities_request)
        path = '/api/v2/feeds/activities/delete'
        # Build request body
        body = delete_activities_request

        # Make the API request
        @client.make_request(
          :post,
          path,
          body: body
        )
      end

      # Query activities based on filters with pagination and sorting options
      #
      # @param query_activities_request [QueryActivitiesRequest]
      # @return [Models::QueryActivitiesResponse]
      def query_activities(query_activities_request)
        path = '/api/v2/feeds/activities/query'
        # Build request body
        body = query_activities_request

        # Make the API request
        @client.make_request(
          :post,
          path,
          body: body
        )
      end

      # Deletes a bookmark from an activity
      #
      # @param activity_id [String]
      # @param folder_id [String]
      # @param user_id [String]
      # @return [Models::DeleteBookmarkResponse]
      def delete_bookmark(activity_id, folder_id = nil, user_id = nil)
        path = '/api/v2/feeds/activities/{activity_id}/bookmarks'
        # Replace path parameters
        path = path.gsub('{activity_id}', activity_id.to_s)
        # Build query parameters
        query_params = {}
        query_params['folder_id'] = folder_id unless folder_id.nil?
        query_params['user_id'] = user_id unless user_id.nil?

        # Make the API request
        @client.make_request(
          :delete,
          path,
          query_params: query_params
        )
      end

      # Updates a bookmark for an activity
      #
      # @param activity_id [String]
      # @param update_bookmark_request [UpdateBookmarkRequest]
      # @return [Models::UpdateBookmarkResponse]
      def update_bookmark(activity_id, update_bookmark_request)
        path = '/api/v2/feeds/activities/{activity_id}/bookmarks'
        # Replace path parameters
        path = path.gsub('{activity_id}', activity_id.to_s)
        # Build request body
        body = update_bookmark_request

        # Make the API request
        @client.make_request(
          :patch,
          path,
          body: body
        )
      end

      # Adds a bookmark to an activity
      #
      # @param activity_id [String]
      # @param add_bookmark_request [AddBookmarkRequest]
      # @return [Models::AddBookmarkResponse]
      def add_bookmark(activity_id, add_bookmark_request)
        path = '/api/v2/feeds/activities/{activity_id}/bookmarks'
        # Replace path parameters
        path = path.gsub('{activity_id}', activity_id.to_s)
        # Build request body
        body = add_bookmark_request

        # Make the API request
        @client.make_request(
          :post,
          path,
          body: body
        )
      end

      # Submit feedback for an activity including options to show less, hide, report, or mute the user
      #
      # @param activity_id [String]
      # @param activity_feedback_request [ActivityFeedbackRequest]
      # @return [Models::ActivityFeedbackResponse]
      def activity_feedback(activity_id, activity_feedback_request)
        path = '/api/v2/feeds/activities/{activity_id}/feedback'
        # Replace path parameters
        path = path.gsub('{activity_id}', activity_id.to_s)
        # Build request body
        body = activity_feedback_request

        # Make the API request
        @client.make_request(
          :post,
          path,
          body: body
        )
      end

      # Cast a vote on a pollSends events:- feeds.poll.vote_casted- feeds.poll.vote_changed- feeds.poll.vote_removed- poll.vote_casted- poll.vote_changed- poll.vote_removed
      #
      # @param activity_id [String]
      # @param poll_id [String]
      # @param cast_poll_vote_request [CastPollVoteRequest]
      # @return [Models::PollVoteResponse]
      def cast_poll_vote(activity_id, poll_id, cast_poll_vote_request)
        path = '/api/v2/feeds/activities/{activity_id}/polls/{poll_id}/vote'
        # Replace path parameters
        path = path.gsub('{activity_id}', activity_id.to_s)
        path = path.gsub('{poll_id}', poll_id.to_s)
        # Build request body
        body = cast_poll_vote_request

        # Make the API request
        @client.make_request(
          :post,
          path,
          body: body
        )
      end

      # Delete a vote from a pollSends events:- feeds.poll.vote_removed- poll.vote_removed
      #
      # @param activity_id [String]
      # @param poll_id [String]
      # @param vote_id [String]
      # @param user_id [String]
      # @return [Models::PollVoteResponse]
      def delete_poll_vote(activity_id, poll_id, vote_id, user_id = nil)
        path = '/api/v2/feeds/activities/{activity_id}/polls/{poll_id}/vote/{vote_id}'
        # Replace path parameters
        path = path.gsub('{activity_id}', activity_id.to_s)
        path = path.gsub('{poll_id}', poll_id.to_s)
        path = path.gsub('{vote_id}', vote_id.to_s)
        # Build query parameters
        query_params = {}
        query_params['user_id'] = user_id unless user_id.nil?

        # Make the API request
        @client.make_request(
          :delete,
          path,
          query_params: query_params
        )
      end

      # Adds a reaction to an activity
      #
      # @param activity_id [String]
      # @param add_reaction_request [AddReactionRequest]
      # @return [Models::AddReactionResponse]
      def add_activity_reaction(activity_id, add_reaction_request)
        path = '/api/v2/feeds/activities/{activity_id}/reactions'
        # Replace path parameters
        path = path.gsub('{activity_id}', activity_id.to_s)
        # Build request body
        body = add_reaction_request

        # Make the API request
        @client.make_request(
          :post,
          path,
          body: body
        )
      end

      # Query activity reactions
      #
      # @param activity_id [String]
      # @param query_activity_reactions_request [QueryActivityReactionsRequest]
      # @return [Models::QueryActivityReactionsResponse]
      def query_activity_reactions(activity_id, query_activity_reactions_request)
        path = '/api/v2/feeds/activities/{activity_id}/reactions/query'
        # Replace path parameters
        path = path.gsub('{activity_id}', activity_id.to_s)
        # Build request body
        body = query_activity_reactions_request

        # Make the API request
        @client.make_request(
          :post,
          path,
          body: body
        )
      end

      # Removes a reaction from an activity
      #
      # @param activity_id [String]
      # @param _type [String]
      # @param user_id [String]
      # @return [Models::DeleteActivityReactionResponse]
      def delete_activity_reaction(activity_id, _type, user_id = nil)
        path = '/api/v2/feeds/activities/{activity_id}/reactions/{type}'
        # Replace path parameters
        path = path.gsub('{activity_id}', activity_id.to_s)
        path = path.gsub('{type}', _type.to_s)
        # Build query parameters
        query_params = {}
        query_params['user_id'] = user_id unless user_id.nil?

        # Make the API request
        @client.make_request(
          :delete,
          path,
          query_params: query_params
        )
      end

      # Delete a single activity by its ID
      #
      # @param _id [String]
      # @param hard_delete [Boolean]
      # @return [Models::DeleteActivityResponse]
      def delete_activity(_id, hard_delete = nil)
        path = '/api/v2/feeds/activities/{id}'
        # Replace path parameters
        path = path.gsub('{id}', _id.to_s)
        # Build query parameters
        query_params = {}
        query_params['hard_delete'] = hard_delete unless hard_delete.nil?

        # Make the API request
        @client.make_request(
          :delete,
          path,
          query_params: query_params
        )
      end

      # Returns activity by ID
      #
      # @param _id [String]
      # @return [Models::GetActivityResponse]
      def get_activity(_id)
        path = '/api/v2/feeds/activities/{id}'
        # Replace path parameters
        path = path.gsub('{id}', _id.to_s)

        # Make the API request
        @client.make_request(
          :get,
          path
        )
      end

      # Updates certain fields of the activity. Use 'set' to update specific fields and 'unset' to remove fields. This allows you to update only the fields you need without replacing the entire activity. Useful for updating reply restrictions ('restrict_replies'), mentioned users, or custom data.Sends events:- feeds.activity.updated
      #
      # @param _id [String]
      # @param update_activity_partial_request [UpdateActivityPartialRequest]
      # @return [Models::UpdateActivityPartialResponse]
      def update_activity_partial(_id, update_activity_partial_request)
        path = '/api/v2/feeds/activities/{id}'
        # Replace path parameters
        path = path.gsub('{id}', _id.to_s)
        # Build request body
        body = update_activity_partial_request

        # Make the API request
        @client.make_request(
          :patch,
          path,
          body: body
        )
      end

      # Replaces an activity with the provided data. Use this to update text, attachments, reply restrictions ('restrict_replies'), mentioned users, and other activity fields. Note: This is a full update - any fields not provided will be cleared.Sends events:- feeds.activity.updated
      #
      # @param _id [String]
      # @param update_activity_request [UpdateActivityRequest]
      # @return [Models::UpdateActivityResponse]
      def update_activity(_id, update_activity_request)
        path = '/api/v2/feeds/activities/{id}'
        # Replace path parameters
        path = path.gsub('{id}', _id.to_s)
        # Build request body
        body = update_activity_request

        # Make the API request
        @client.make_request(
          :put,
          path,
          body: body
        )
      end

      # Query bookmark folders with filter query
      #
      # @param query_bookmark_folders_request [QueryBookmarkFoldersRequest]
      # @return [Models::QueryBookmarkFoldersResponse]
      def query_bookmark_folders(query_bookmark_folders_request)
        path = '/api/v2/feeds/bookmark_folders/query'
        # Build request body
        body = query_bookmark_folders_request

        # Make the API request
        @client.make_request(
          :post,
          path,
          body: body
        )
      end

      # Delete a bookmark folder by its ID
      #
      # @param folder_id [String]
      # @return [Models::DeleteBookmarkFolderResponse]
      def delete_bookmark_folder(folder_id)
        path = '/api/v2/feeds/bookmark_folders/{folder_id}'
        # Replace path parameters
        path = path.gsub('{folder_id}', folder_id.to_s)

        # Make the API request
        @client.make_request(
          :delete,
          path
        )
      end

      # Update a bookmark folder by its ID
      #
      # @param folder_id [String]
      # @param update_bookmark_folder_request [UpdateBookmarkFolderRequest]
      # @return [Models::UpdateBookmarkFolderResponse]
      def update_bookmark_folder(folder_id, update_bookmark_folder_request)
        path = '/api/v2/feeds/bookmark_folders/{folder_id}'
        # Replace path parameters
        path = path.gsub('{folder_id}', folder_id.to_s)
        # Build request body
        body = update_bookmark_folder_request

        # Make the API request
        @client.make_request(
          :patch,
          path,
          body: body
        )
      end

      # Query bookmarks with filter query
      #
      # @param query_bookmarks_request [QueryBookmarksRequest]
      # @return [Models::QueryBookmarksResponse]
      def query_bookmarks(query_bookmarks_request)
        path = '/api/v2/feeds/bookmarks/query'
        # Build request body
        body = query_bookmarks_request

        # Make the API request
        @client.make_request(
          :post,
          path,
          body: body
        )
      end

      # Delete collections in a batch operation. Users can only delete their own collections.
      #
      # @param collection_refs [Array<String>]
      # @return [Models::DeleteCollectionsResponse]
      def delete_collections(collection_refs)
        path = '/api/v2/feeds/collections'
        # Build query parameters
        query_params = {}
        query_params['collection_refs'] = collection_refs unless collection_refs.nil?

        # Make the API request
        @client.make_request(
          :delete,
          path,
          query_params: query_params
        )
      end

      # Read collections with optional filtering by user ID and collection name. By default, users can only read their own collections.
      #
      # @param collection_refs [Array<String>]
      # @param user_id [String]
      # @return [Models::ReadCollectionsResponse]
      def read_collections(collection_refs, user_id = nil)
        path = '/api/v2/feeds/collections'
        # Build query parameters
        query_params = {}
        query_params['collection_refs'] = collection_refs unless collection_refs.nil?
        query_params['user_id'] = user_id unless user_id.nil?

        # Make the API request
        @client.make_request(
          :get,
          path,
          query_params: query_params
        )
      end

      # Update existing collections in a batch operation. Only the custom data field is updatable. Users can only update their own collections.
      #
      # @param update_collections_request [UpdateCollectionsRequest]
      # @return [Models::UpdateCollectionsResponse]
      def update_collections(update_collections_request)
        path = '/api/v2/feeds/collections'
        # Build request body
        body = update_collections_request

        # Make the API request
        @client.make_request(
          :patch,
          path,
          body: body
        )
      end

      # Create new collections in a batch operation. Collections are data objects that can be attached to activities for managing shared data across multiple activities.
      #
      # @param create_collections_request [CreateCollectionsRequest]
      # @return [Models::CreateCollectionsResponse]
      def create_collections(create_collections_request)
        path = '/api/v2/feeds/collections'
        # Build request body
        body = create_collections_request

        # Make the API request
        @client.make_request(
          :post,
          path,
          body: body
        )
      end

      # Insert new collections or update existing ones in a batch operation. Only the custom data field is updatable for existing collections.
      #
      # @param upsert_collections_request [UpsertCollectionsRequest]
      # @return [Models::UpsertCollectionsResponse]
      def upsert_collections(upsert_collections_request)
        path = '/api/v2/feeds/collections'
        # Build request body
        body = upsert_collections_request

        # Make the API request
        @client.make_request(
          :put,
          path,
          body: body
        )
      end

      # Retrieve a threaded list of comments for a specific object (e.g., activity), with configurable depth, sorting, and pagination
      #
      # @param object_id [String]
      # @param object_type [String]
      # @param depth [Integer]
      # @param sort [String]
      # @param replies_limit [Integer]
      # @param limit [Integer]
      # @param prev [String]
      # @param _next [String]
      # @return [Models::GetCommentsResponse]
      def get_comments(object_id, object_type, depth = nil, sort = nil, replies_limit = nil, limit = nil, prev = nil, _next = nil)
        path = '/api/v2/feeds/comments'
        # Build query parameters
        query_params = {}
        query_params['object_id'] = object_id unless object_id.nil?
        query_params['object_type'] = object_type unless object_type.nil?
        query_params['depth'] = depth unless depth.nil?
        query_params['sort'] = sort unless sort.nil?
        query_params['replies_limit'] = replies_limit unless replies_limit.nil?
        query_params['limit'] = limit unless limit.nil?
        query_params['prev'] = prev unless prev.nil?
        query_params['next'] = _next unless _next.nil?

        # Make the API request
        @client.make_request(
          :get,
          path,
          query_params: query_params
        )
      end

      # Adds a comment to an object (e.g., activity) or a reply to an existing comment, and broadcasts appropriate events
      #
      # @param add_comment_request [AddCommentRequest]
      # @return [Models::AddCommentResponse]
      def add_comment(add_comment_request)
        path = '/api/v2/feeds/comments'
        # Build request body
        body = add_comment_request

        # Make the API request
        @client.make_request(
          :post,
          path,
          body: body
        )
      end

      # Adds multiple comments in a single request. Each comment must specify the object type and ID.
      #
      # @param add_comments_batch_request [AddCommentsBatchRequest]
      # @return [Models::AddCommentsBatchResponse]
      def add_comments_batch(add_comments_batch_request)
        path = '/api/v2/feeds/comments/batch'
        # Build request body
        body = add_comments_batch_request

        # Make the API request
        @client.make_request(
          :post,
          path,
          body: body
        )
      end

      # Query comments using MongoDB-style filters with pagination and sorting options
      #
      # @param query_comments_request [QueryCommentsRequest]
      # @return [Models::QueryCommentsResponse]
      def query_comments(query_comments_request)
        path = '/api/v2/feeds/comments/query'
        # Build request body
        body = query_comments_request

        # Make the API request
        @client.make_request(
          :post,
          path,
          body: body
        )
      end

      # Deletes a comment from an object (e.g., activity) and broadcasts appropriate events
      #
      # @param _id [String]
      # @param hard_delete [Boolean]
      # @return [Models::DeleteCommentResponse]
      def delete_comment(_id, hard_delete = nil)
        path = '/api/v2/feeds/comments/{id}'
        # Replace path parameters
        path = path.gsub('{id}', _id.to_s)
        # Build query parameters
        query_params = {}
        query_params['hard_delete'] = hard_delete unless hard_delete.nil?

        # Make the API request
        @client.make_request(
          :delete,
          path,
          query_params: query_params
        )
      end

      # Get a comment by ID
      #
      # @param _id [String]
      # @return [Models::GetCommentResponse]
      def get_comment(_id)
        path = '/api/v2/feeds/comments/{id}'
        # Replace path parameters
        path = path.gsub('{id}', _id.to_s)

        # Make the API request
        @client.make_request(
          :get,
          path
        )
      end

      # Updates a comment on an object (e.g., activity) and broadcasts appropriate events
      #
      # @param _id [String]
      # @param update_comment_request [UpdateCommentRequest]
      # @return [Models::UpdateCommentResponse]
      def update_comment(_id, update_comment_request)
        path = '/api/v2/feeds/comments/{id}'
        # Replace path parameters
        path = path.gsub('{id}', _id.to_s)
        # Build request body
        body = update_comment_request

        # Make the API request
        @client.make_request(
          :patch,
          path,
          body: body
        )
      end

      # Adds a reaction to a comment
      #
      # @param _id [String]
      # @param add_comment_reaction_request [AddCommentReactionRequest]
      # @return [Models::AddCommentReactionResponse]
      def add_comment_reaction(_id, add_comment_reaction_request)
        path = '/api/v2/feeds/comments/{id}/reactions'
        # Replace path parameters
        path = path.gsub('{id}', _id.to_s)
        # Build request body
        body = add_comment_reaction_request

        # Make the API request
        @client.make_request(
          :post,
          path,
          body: body
        )
      end

      # Query comment reactions
      #
      # @param _id [String]
      # @param query_comment_reactions_request [QueryCommentReactionsRequest]
      # @return [Models::QueryCommentReactionsResponse]
      def query_comment_reactions(_id, query_comment_reactions_request)
        path = '/api/v2/feeds/comments/{id}/reactions/query'
        # Replace path parameters
        path = path.gsub('{id}', _id.to_s)
        # Build request body
        body = query_comment_reactions_request

        # Make the API request
        @client.make_request(
          :post,
          path,
          body: body
        )
      end

      # Deletes a reaction from a comment
      #
      # @param _id [String]
      # @param _type [String]
      # @param user_id [String]
      # @return [Models::DeleteCommentReactionResponse]
      def delete_comment_reaction(_id, _type, user_id = nil)
        path = '/api/v2/feeds/comments/{id}/reactions/{type}'
        # Replace path parameters
        path = path.gsub('{id}', _id.to_s)
        path = path.gsub('{type}', _type.to_s)
        # Build query parameters
        query_params = {}
        query_params['user_id'] = user_id unless user_id.nil?

        # Make the API request
        @client.make_request(
          :delete,
          path,
          query_params: query_params
        )
      end

      # Retrieve a threaded list of replies for a single comment, with configurable depth, sorting, and pagination
      #
      # @param _id [String]
      # @param depth [Integer]
      # @param sort [String]
      # @param replies_limit [Integer]
      # @param limit [Integer]
      # @param prev [String]
      # @param _next [String]
      # @return [Models::GetCommentRepliesResponse]
      def get_comment_replies(_id, depth = nil, sort = nil, replies_limit = nil, limit = nil, prev = nil, _next = nil)
        path = '/api/v2/feeds/comments/{id}/replies'
        # Replace path parameters
        path = path.gsub('{id}', _id.to_s)
        # Build query parameters
        query_params = {}
        query_params['depth'] = depth unless depth.nil?
        query_params['sort'] = sort unless sort.nil?
        query_params['replies_limit'] = replies_limit unless replies_limit.nil?
        query_params['limit'] = limit unless limit.nil?
        query_params['prev'] = prev unless prev.nil?
        query_params['next'] = _next unless _next.nil?

        # Make the API request
        @client.make_request(
          :get,
          path,
          query_params: query_params
        )
      end

      # List all feed groups for the application
      #
      # @param include_soft_deleted [Boolean]
      # @return [Models::ListFeedGroupsResponse]
      def list_feed_groups(include_soft_deleted = nil)
        path = '/api/v2/feeds/feed_groups'
        # Build query parameters
        query_params = {}
        query_params['include_soft_deleted'] = include_soft_deleted unless include_soft_deleted.nil?

        # Make the API request
        @client.make_request(
          :get,
          path,
          query_params: query_params
        )
      end

      # Creates a new feed group with the specified configuration
      #
      # @param create_feed_group_request [CreateFeedGroupRequest]
      # @return [Models::CreateFeedGroupResponse]
      def create_feed_group(create_feed_group_request)
        path = '/api/v2/feeds/feed_groups'
        # Build request body
        body = create_feed_group_request

        # Make the API request
        @client.make_request(
          :post,
          path,
          body: body
        )
      end

      # Delete a single feed by its ID
      #
      # @param feed_group_id [String]
      # @param feed_id [String]
      # @param hard_delete [Boolean]
      # @return [Models::DeleteFeedResponse]
      def delete_feed(feed_group_id, feed_id, hard_delete = nil)
        path = '/api/v2/feeds/feed_groups/{feed_group_id}/feeds/{feed_id}'
        # Replace path parameters
        path = path.gsub('{feed_group_id}', feed_group_id.to_s)
        path = path.gsub('{feed_id}', feed_id.to_s)
        # Build query parameters
        query_params = {}
        query_params['hard_delete'] = hard_delete unless hard_delete.nil?

        # Make the API request
        @client.make_request(
          :delete,
          path,
          query_params: query_params
        )
      end

      # Create a single feed for a given feed group
      #
      # @param feed_group_id [String]
      # @param feed_id [String]
      # @param get_or_create_feed_request [GetOrCreateFeedRequest]
      # @return [Models::GetOrCreateFeedResponse]
      def get_or_create_feed(feed_group_id, feed_id, get_or_create_feed_request)
        path = '/api/v2/feeds/feed_groups/{feed_group_id}/feeds/{feed_id}'
        # Replace path parameters
        path = path.gsub('{feed_group_id}', feed_group_id.to_s)
        path = path.gsub('{feed_id}', feed_id.to_s)
        # Build request body
        body = get_or_create_feed_request

        # Make the API request
        @client.make_request(
          :post,
          path,
          body: body
        )
      end

      # Update an existing feed
      #
      # @param feed_group_id [String]
      # @param feed_id [String]
      # @param update_feed_request [UpdateFeedRequest]
      # @return [Models::UpdateFeedResponse]
      def update_feed(feed_group_id, feed_id, update_feed_request)
        path = '/api/v2/feeds/feed_groups/{feed_group_id}/feeds/{feed_id}'
        # Replace path parameters
        path = path.gsub('{feed_group_id}', feed_group_id.to_s)
        path = path.gsub('{feed_id}', feed_id.to_s)
        # Build request body
        body = update_feed_request

        # Make the API request
        @client.make_request(
          :put,
          path,
          body: body
        )
      end

      # Mark activities as read/seen/watched. Can mark by timestamp (seen), activity IDs (read), or all as read.
      #
      # @param feed_group_id [String]
      # @param feed_id [String]
      # @param mark_activity_request [MarkActivityRequest]
      # @return [Models::Response]
      def mark_activity(feed_group_id, feed_id, mark_activity_request)
        path = '/api/v2/feeds/feed_groups/{feed_group_id}/feeds/{feed_id}/activities/mark/batch'
        # Replace path parameters
        path = path.gsub('{feed_group_id}', feed_group_id.to_s)
        path = path.gsub('{feed_id}', feed_id.to_s)
        # Build request body
        body = mark_activity_request

        # Make the API request
        @client.make_request(
          :post,
          path,
          body: body
        )
      end

      # Unpin an activity from a feed. This removes the pin, so the activity will no longer be displayed at the top of the feed.
      #
      # @param feed_group_id [String]
      # @param feed_id [String]
      # @param activity_id [String]
      # @param user_id [String]
      # @return [Models::UnpinActivityResponse]
      def unpin_activity(feed_group_id, feed_id, activity_id, user_id = nil)
        path = '/api/v2/feeds/feed_groups/{feed_group_id}/feeds/{feed_id}/activities/{activity_id}/pin'
        # Replace path parameters
        path = path.gsub('{feed_group_id}', feed_group_id.to_s)
        path = path.gsub('{feed_id}', feed_id.to_s)
        path = path.gsub('{activity_id}', activity_id.to_s)
        # Build query parameters
        query_params = {}
        query_params['user_id'] = user_id unless user_id.nil?

        # Make the API request
        @client.make_request(
          :delete,
          path,
          query_params: query_params
        )
      end

      # Pin an activity to a feed. Pinned activities are typically displayed at the top of a feed.
      #
      # @param feed_group_id [String]
      # @param feed_id [String]
      # @param activity_id [String]
      # @param pin_activity_request [PinActivityRequest]
      # @return [Models::PinActivityResponse]
      def pin_activity(feed_group_id, feed_id, activity_id, pin_activity_request)
        path = '/api/v2/feeds/feed_groups/{feed_group_id}/feeds/{feed_id}/activities/{activity_id}/pin'
        # Replace path parameters
        path = path.gsub('{feed_group_id}', feed_group_id.to_s)
        path = path.gsub('{feed_id}', feed_id.to_s)
        path = path.gsub('{activity_id}', activity_id.to_s)
        # Build request body
        body = pin_activity_request

        # Make the API request
        @client.make_request(
          :post,
          path,
          body: body
        )
      end

      # Add, remove, or set members for a feed
      #
      # @param feed_group_id [String]
      # @param feed_id [String]
      # @param update_feed_members_request [UpdateFeedMembersRequest]
      # @return [Models::UpdateFeedMembersResponse]
      def update_feed_members(feed_group_id, feed_id, update_feed_members_request)
        path = '/api/v2/feeds/feed_groups/{feed_group_id}/feeds/{feed_id}/members'
        # Replace path parameters
        path = path.gsub('{feed_group_id}', feed_group_id.to_s)
        path = path.gsub('{feed_id}', feed_id.to_s)
        # Build request body
        body = update_feed_members_request

        # Make the API request
        @client.make_request(
          :patch,
          path,
          body: body
        )
      end

      # Accepts a pending feed member request
      #
      # @param feed_id [String]
      # @param feed_group_id [String]
      # @param accept_feed_member_invite_request [AcceptFeedMemberInviteRequest]
      # @return [Models::AcceptFeedMemberInviteResponse]
      def accept_feed_member_invite(feed_id, feed_group_id, accept_feed_member_invite_request)
        path = '/api/v2/feeds/feed_groups/{feed_group_id}/feeds/{feed_id}/members/accept'
        # Replace path parameters
        path = path.gsub('{feed_id}', feed_id.to_s)
        path = path.gsub('{feed_group_id}', feed_group_id.to_s)
        # Build request body
        body = accept_feed_member_invite_request

        # Make the API request
        @client.make_request(
          :post,
          path,
          body: body
        )
      end

      # Query feed members based on filters with pagination and sorting options
      #
      # @param feed_group_id [String]
      # @param feed_id [String]
      # @param query_feed_members_request [QueryFeedMembersRequest]
      # @return [Models::QueryFeedMembersResponse]
      def query_feed_members(feed_group_id, feed_id, query_feed_members_request)
        path = '/api/v2/feeds/feed_groups/{feed_group_id}/feeds/{feed_id}/members/query'
        # Replace path parameters
        path = path.gsub('{feed_group_id}', feed_group_id.to_s)
        path = path.gsub('{feed_id}', feed_id.to_s)
        # Build request body
        body = query_feed_members_request

        # Make the API request
        @client.make_request(
          :post,
          path,
          body: body
        )
      end

      # Rejects a pending feed member request
      #
      # @param feed_group_id [String]
      # @param feed_id [String]
      # @param reject_feed_member_invite_request [RejectFeedMemberInviteRequest]
      # @return [Models::RejectFeedMemberInviteResponse]
      def reject_feed_member_invite(feed_group_id, feed_id, reject_feed_member_invite_request)
        path = '/api/v2/feeds/feed_groups/{feed_group_id}/feeds/{feed_id}/members/reject'
        # Replace path parameters
        path = path.gsub('{feed_group_id}', feed_group_id.to_s)
        path = path.gsub('{feed_id}', feed_id.to_s)
        # Build request body
        body = reject_feed_member_invite_request

        # Make the API request
        @client.make_request(
          :post,
          path,
          body: body
        )
      end

      # Get follow suggestions for a feed group
      #
      # @param feed_group_id [String]
      # @param limit [Integer]
      # @param user_id [String]
      # @return [Models::GetFollowSuggestionsResponse]
      def get_follow_suggestions(feed_group_id, limit = nil, user_id = nil)
        path = '/api/v2/feeds/feed_groups/{feed_group_id}/follow_suggestions'
        # Replace path parameters
        path = path.gsub('{feed_group_id}', feed_group_id.to_s)
        # Build query parameters
        query_params = {}
        query_params['limit'] = limit unless limit.nil?
        query_params['user_id'] = user_id unless user_id.nil?

        # Make the API request
        @client.make_request(
          :get,
          path,
          query_params: query_params
        )
      end

      # Delete a feed group by its ID. Can perform a soft delete (default) or hard delete.
      #
      # @param _id [String]
      # @param hard_delete [Boolean]
      # @return [Models::DeleteFeedGroupResponse]
      def delete_feed_group(_id, hard_delete = nil)
        path = '/api/v2/feeds/feed_groups/{id}'
        # Replace path parameters
        path = path.gsub('{id}', _id.to_s)
        # Build query parameters
        query_params = {}
        query_params['hard_delete'] = hard_delete unless hard_delete.nil?

        # Make the API request
        @client.make_request(
          :delete,
          path,
          query_params: query_params
        )
      end

      # Get a feed group by ID
      #
      # @param _id [String]
      # @param include_soft_deleted [Boolean]
      # @return [Models::GetFeedGroupResponse]
      def get_feed_group(_id, include_soft_deleted = nil)
        path = '/api/v2/feeds/feed_groups/{id}'
        # Replace path parameters
        path = path.gsub('{id}', _id.to_s)
        # Build query parameters
        query_params = {}
        query_params['include_soft_deleted'] = include_soft_deleted unless include_soft_deleted.nil?

        # Make the API request
        @client.make_request(
          :get,
          path,
          query_params: query_params
        )
      end

      # Get an existing feed group or create a new one if it doesn't exist
      #
      # @param _id [String]
      # @param get_or_create_feed_group_request [GetOrCreateFeedGroupRequest]
      # @return [Models::GetOrCreateFeedGroupResponse]
      def get_or_create_feed_group(_id, get_or_create_feed_group_request)
        path = '/api/v2/feeds/feed_groups/{id}'
        # Replace path parameters
        path = path.gsub('{id}', _id.to_s)
        # Build request body
        body = get_or_create_feed_group_request

        # Make the API request
        @client.make_request(
          :post,
          path,
          body: body
        )
      end

      # Update a feed group by ID
      #
      # @param _id [String]
      # @param update_feed_group_request [UpdateFeedGroupRequest]
      # @return [Models::UpdateFeedGroupResponse]
      def update_feed_group(_id, update_feed_group_request)
        path = '/api/v2/feeds/feed_groups/{id}'
        # Replace path parameters
        path = path.gsub('{id}', _id.to_s)
        # Build request body
        body = update_feed_group_request

        # Make the API request
        @client.make_request(
          :put,
          path,
          body: body
        )
      end

      # List all feed views for a feed group
      #
      # @return [Models::ListFeedViewsResponse]
      def list_feed_views()
        path = '/api/v2/feeds/feed_views'

        # Make the API request
        @client.make_request(
          :get,
          path
        )
      end

      # Create a custom view for a feed group with specific selectors, ranking, or aggregation options
      #
      # @param create_feed_view_request [CreateFeedViewRequest]
      # @return [Models::CreateFeedViewResponse]
      def create_feed_view(create_feed_view_request)
        path = '/api/v2/feeds/feed_views'
        # Build request body
        body = create_feed_view_request

        # Make the API request
        @client.make_request(
          :post,
          path,
          body: body
        )
      end

      # Delete an existing custom feed view
      #
      # @param _id [String]
      # @return [Models::DeleteFeedViewResponse]
      def delete_feed_view(_id)
        path = '/api/v2/feeds/feed_views/{id}'
        # Replace path parameters
        path = path.gsub('{id}', _id.to_s)

        # Make the API request
        @client.make_request(
          :delete,
          path
        )
      end

      # Get a feed view by its ID
      #
      # @param _id [String]
      # @return [Models::GetFeedViewResponse]
      def get_feed_view(_id)
        path = '/api/v2/feeds/feed_views/{id}'
        # Replace path parameters
        path = path.gsub('{id}', _id.to_s)

        # Make the API request
        @client.make_request(
          :get,
          path
        )
      end

      # Get an existing feed view or create a new one if it doesn't exist
      #
      # @param _id [String]
      # @param get_or_create_feed_view_request [GetOrCreateFeedViewRequest]
      # @return [Models::GetOrCreateFeedViewResponse]
      def get_or_create_feed_view(_id, get_or_create_feed_view_request)
        path = '/api/v2/feeds/feed_views/{id}'
        # Replace path parameters
        path = path.gsub('{id}', _id.to_s)
        # Build request body
        body = get_or_create_feed_view_request

        # Make the API request
        @client.make_request(
          :post,
          path,
          body: body
        )
      end

      # Update an existing custom feed view with new selectors, ranking, or aggregation options
      #
      # @param _id [String]
      # @param update_feed_view_request [UpdateFeedViewRequest]
      # @return [Models::UpdateFeedViewResponse]
      def update_feed_view(_id, update_feed_view_request)
        path = '/api/v2/feeds/feed_views/{id}'
        # Replace path parameters
        path = path.gsub('{id}', _id.to_s)
        # Build request body
        body = update_feed_view_request

        # Make the API request
        @client.make_request(
          :put,
          path,
          body: body
        )
      end

      # Gets all available feed visibility configurations and their permissions
      #
      # @return [Models::ListFeedVisibilitiesResponse]
      def list_feed_visibilities()
        path = '/api/v2/feeds/feed_visibilities'

        # Make the API request
        @client.make_request(
          :get,
          path
        )
      end

      # Gets feed visibility configuration and permissions
      #
      # @param name [String]
      # @return [Models::GetFeedVisibilityResponse]
      def get_feed_visibility(name)
        path = '/api/v2/feeds/feed_visibilities/{name}'
        # Replace path parameters
        path = path.gsub('{name}', name.to_s)

        # Make the API request
        @client.make_request(
          :get,
          path
        )
      end

      # Updates an existing predefined feed visibility configuration
      #
      # @param name [String]
      # @param update_feed_visibility_request [UpdateFeedVisibilityRequest]
      # @return [Models::UpdateFeedVisibilityResponse]
      def update_feed_visibility(name, update_feed_visibility_request)
        path = '/api/v2/feeds/feed_visibilities/{name}'
        # Replace path parameters
        path = path.gsub('{name}', name.to_s)
        # Build request body
        body = update_feed_visibility_request

        # Make the API request
        @client.make_request(
          :put,
          path,
          body: body
        )
      end

      # Create multiple feeds at once for a given feed group
      #
      # @param create_feeds_batch_request [CreateFeedsBatchRequest]
      # @return [Models::CreateFeedsBatchResponse]
      def create_feeds_batch(create_feeds_batch_request)
        path = '/api/v2/feeds/feeds/batch'
        # Build request body
        body = create_feeds_batch_request

        # Make the API request
        @client.make_request(
          :post,
          path,
          body: body
        )
      end

      # Delete multiple feeds by their IDs. All feeds must exist. This endpoint is server-side only.
      #
      # @param delete_feeds_batch_request [DeleteFeedsBatchRequest]
      # @return [Models::DeleteFeedsBatchResponse]
      def delete_feeds_batch(delete_feeds_batch_request)
        path = '/api/v2/feeds/feeds/delete'
        # Build request body
        body = delete_feeds_batch_request

        # Make the API request
        @client.make_request(
          :post,
          path,
          body: body
        )
      end

      # Retrieves own_follows, own_capabilities, and/or own_membership for multiple feeds in a single request. If fields are not specified, all three fields are returned.
      #
      # @param own_batch_request [OwnBatchRequest]
      # @return [Models::OwnBatchResponse]
      def own_batch(own_batch_request)
        path = '/api/v2/feeds/feeds/own/batch'
        # Build request body
        body = own_batch_request

        # Make the API request
        @client.make_request(
          :post,
          path,
          body: body
        )
      end

      # Query feeds with filter query
      #
      # @param query_feeds_request [QueryFeedsRequest]
      # @return [Models::QueryFeedsResponse]
      def query_feeds(query_feeds_request)
        path = '/api/v2/feeds/feeds/query'
        # Build request body
        body = query_feeds_request

        # Make the API request
        @client.make_request(
          :post,
          path,
          body: body
        )
      end

      # Retrieve current rate limit status for feeds operations.Returns information about limits, usage, and remaining quota for various feed operations.
      #
      # @param endpoints [String]
      # @param android [Boolean]
      # @param ios [Boolean]
      # @param web [Boolean]
      # @param server_side [Boolean]
      # @return [Models::GetFeedsRateLimitsResponse]
      def get_feeds_rate_limits(endpoints = nil, android = nil, ios = nil, web = nil, server_side = nil)
        path = '/api/v2/feeds/feeds/rate_limits'
        # Build query parameters
        query_params = {}
        query_params['endpoints'] = endpoints unless endpoints.nil?
        query_params['android'] = android unless android.nil?
        query_params['ios'] = ios unless ios.nil?
        query_params['web'] = web unless web.nil?
        query_params['server_side'] = server_side unless server_side.nil?

        # Make the API request
        @client.make_request(
          :get,
          path,
          query_params: query_params
        )
      end

      # Updates a follow's custom data, push preference, and follower role. Source owner can update custom data and push preference. Follower role can only be updated via server-side requests.
      #
      # @param update_follow_request [UpdateFollowRequest]
      # @return [Models::UpdateFollowResponse]
      def update_follow(update_follow_request)
        path = '/api/v2/feeds/follows'
        # Build request body
        body = update_follow_request

        # Make the API request
        @client.make_request(
          :patch,
          path,
          body: body
        )
      end

      # Creates a follow and broadcasts FollowAddedEvent
      #
      # @param follow_request [FollowRequest]
      # @return [Models::SingleFollowResponse]
      def follow(follow_request)
        path = '/api/v2/feeds/follows'
        # Build request body
        body = follow_request

        # Make the API request
        @client.make_request(
          :post,
          path,
          body: body
        )
      end

      # Accepts a pending follow request
      #
      # @param accept_follow_request [AcceptFollowRequest]
      # @return [Models::AcceptFollowResponse]
      def accept_follow(accept_follow_request)
        path = '/api/v2/feeds/follows/accept'
        # Build request body
        body = accept_follow_request

        # Make the API request
        @client.make_request(
          :post,
          path,
          body: body
        )
      end

      # Creates multiple follows at once and broadcasts FollowAddedEvent for each follow
      #
      # @param follow_batch_request [FollowBatchRequest]
      # @return [Models::FollowBatchResponse]
      def follow_batch(follow_batch_request)
        path = '/api/v2/feeds/follows/batch'
        # Build request body
        body = follow_batch_request

        # Make the API request
        @client.make_request(
          :post,
          path,
          body: body
        )
      end

      # Creates or updates multiple follows at once. Does not return an error if follows already exist. Broadcasts FollowAddedEvent only for newly created follows.
      #
      # @param follow_batch_request [FollowBatchRequest]
      # @return [Models::FollowBatchResponse]
      def get_or_create_follows(follow_batch_request)
        path = '/api/v2/feeds/follows/batch/upsert'
        # Build request body
        body = follow_batch_request

        # Make the API request
        @client.make_request(
          :post,
          path,
          body: body
        )
      end

      # Query follows based on filters with pagination and sorting options
      #
      # @param query_follows_request [QueryFollowsRequest]
      # @return [Models::QueryFollowsResponse]
      def query_follows(query_follows_request)
        path = '/api/v2/feeds/follows/query'
        # Build request body
        body = query_follows_request

        # Make the API request
        @client.make_request(
          :post,
          path,
          body: body
        )
      end

      # Rejects a pending follow request
      #
      # @param reject_follow_request [RejectFollowRequest]
      # @return [Models::RejectFollowResponse]
      def reject_follow(reject_follow_request)
        path = '/api/v2/feeds/follows/reject'
        # Build request body
        body = reject_follow_request

        # Make the API request
        @client.make_request(
          :post,
          path,
          body: body
        )
      end

      # Removes a follow and broadcasts FollowRemovedEvent
      #
      # @param source [String]
      # @param target [String]
      # @return [Models::UnfollowResponse]
      def unfollow(source, target)
        path = '/api/v2/feeds/follows/{source}/{target}'
        # Replace path parameters
        path = path.gsub('{source}', source.to_s)
        path = path.gsub('{target}', target.to_s)

        # Make the API request
        @client.make_request(
          :delete,
          path
        )
      end

      # Create a new membership level with tag-based access controls
      #
      # @param create_membership_level_request [CreateMembershipLevelRequest]
      # @return [Models::CreateMembershipLevelResponse]
      def create_membership_level(create_membership_level_request)
        path = '/api/v2/feeds/membership_levels'
        # Build request body
        body = create_membership_level_request

        # Make the API request
        @client.make_request(
          :post,
          path,
          body: body
        )
      end

      # Query membership levels with filter query
      #
      # @param query_membership_levels_request [QueryMembershipLevelsRequest]
      # @return [Models::QueryMembershipLevelsResponse]
      def query_membership_levels(query_membership_levels_request)
        path = '/api/v2/feeds/membership_levels/query'
        # Build request body
        body = query_membership_levels_request

        # Make the API request
        @client.make_request(
          :post,
          path,
          body: body
        )
      end

      # Delete a membership level by its UUID. This operation is irreversible.
      #
      # @param _id [String]
      # @return [Models::Response]
      def delete_membership_level(_id)
        path = '/api/v2/feeds/membership_levels/{id}'
        # Replace path parameters
        path = path.gsub('{id}', _id.to_s)

        # Make the API request
        @client.make_request(
          :delete,
          path
        )
      end

      # Update a membership level with partial updates. Only specified fields will be updated.
      #
      # @param _id [String]
      # @param update_membership_level_request [UpdateMembershipLevelRequest]
      # @return [Models::UpdateMembershipLevelResponse]
      def update_membership_level(_id, update_membership_level_request)
        path = '/api/v2/feeds/membership_levels/{id}'
        # Replace path parameters
        path = path.gsub('{id}', _id.to_s)
        # Build request body
        body = update_membership_level_request

        # Make the API request
        @client.make_request(
          :patch,
          path,
          body: body
        )
      end

      # Retrieve usage statistics for feeds including activity count, follow count, and API request count.Returns data aggregated by day with pagination support via from/to date parameters.This endpoint is server-side only.
      #
      # @param query_feeds_usage_stats_request [QueryFeedsUsageStatsRequest]
      # @return [Models::QueryFeedsUsageStatsResponse]
      def query_feeds_usage_stats(query_feeds_usage_stats_request)
        path = '/api/v2/feeds/stats/usage'
        # Build request body
        body = query_feeds_usage_stats_request

        # Make the API request
        @client.make_request(
          :post,
          path,
          body: body
        )
      end

      # Removes multiple follows at once and broadcasts FollowRemovedEvent for each one
      #
      # @param unfollow_batch_request [UnfollowBatchRequest]
      # @return [Models::UnfollowBatchResponse]
      def unfollow_batch(unfollow_batch_request)
        path = '/api/v2/feeds/unfollow/batch'
        # Build request body
        body = unfollow_batch_request

        # Make the API request
        @client.make_request(
          :post,
          path,
          body: body
        )
      end

      # Removes multiple follows and broadcasts FollowRemovedEvent for each. Does not return an error if follows don't exist.
      #
      # @param unfollow_batch_request [UnfollowBatchRequest]
      # @return [Models::UnfollowBatchResponse]
      def get_or_create_unfollows(unfollow_batch_request)
        path = '/api/v2/feeds/unfollow/batch/upsert'
        # Build request body
        body = unfollow_batch_request

        # Make the API request
        @client.make_request(
          :post,
          path,
          body: body
        )
      end

      # Delete all feed data for a user including: feeds, activities, follows, comments, feed reactions, bookmark folders, bookmarks, and collections owned by the user
      #
      # @param user_id [String]
      # @param delete_feed_user_data_request [DeleteFeedUserDataRequest]
      # @return [Models::DeleteFeedUserDataResponse]
      def delete_feed_user_data(user_id, delete_feed_user_data_request)
        path = '/api/v2/feeds/users/{user_id}/delete'
        # Replace path parameters
        path = path.gsub('{user_id}', user_id.to_s)
        # Build request body
        body = delete_feed_user_data_request

        # Make the API request
        @client.make_request(
          :post,
          path,
          body: body
        )
      end

      # Export all feed data for a user including: user profile, feeds, activities, follows, comments, feed reactions, bookmark folders, bookmarks, and collections owned by the user
      #
      # @param user_id [String]
      # @return [Models::ExportFeedUserDataResponse]
      def export_feed_user_data(user_id)
        path = '/api/v2/feeds/users/{user_id}/export'
        # Replace path parameters
        path = path.gsub('{user_id}', user_id.to_s)

        # Make the API request
        @client.make_request(
          :post,
          path
        )
      end

    end
  end
end